# 汇编语言基础

## 基本语言元素

### 第一个汇编语言程序

* 汇编语言是一种几乎提供全部信息的语言。程序员可以看到正在发生的所有事情，包括CPU中寄存器和标志！ 单拥有能力的同时，程序员必须负责处理数据表示的细节和指令的格式。

* 汇编程序，两数相加

  ```asm
  main PROC
  	mov eax, 5	; 将数字5送入寄存器eax
  	add eax, 6	; eax寄存器加6
  	
  	INVOKE ExitProcess, 0	; 程序结束, 调用Windows服务
  main ENDP
  ```

* 添加一个变量

  ```asm
  .data	; 此为数据区, 
  sum DWORD 0		; 定义名为sum的变量
  
  .code	; 此为代码区
  main PROC	
  	mov eax, 5
  	add eax, 6
  	mov sum, eax
  	
  	INVOKE ExitProcess, 0	; 程序结束
  main ENDP
  ```

  * 被伪指令标识的代码和数据区，被称为段。即程序有代码段和数据段。(还有第三种段，堆栈 stack )

### 整数常量

1. 整数常量(integer literall)(又称为整型常量(integer constant))由可选前置符号， 一个或多个数字，以及一个指明其基数的可选基数字符构成:
   * `[{+ | -}] digits [radix]`
2. 进制基数
   1. `h`: 十六进制： 注意，以字母开头的十六进制数，必须在前面加0
   2. `q/o`: 八进制
   3. `d`: 十进制
   4. `b`: 二进制

### 整形常量表达式

* 整形常量表达式(constant integer expression)是一个算术表达式，它包含了整数常量和算术运算符。每个表达式的计算结果必须是一个整数，并且可用32位来存放。
  * `()`: 圆括号
  * `+, -`: 一元加减
  * `*, /`: 乘， 除
  * `MOD`: 取模
  * `+, -`: 加减

### 实数常量

* 实数常量(real number literal)( 又称为浮点数常量(floating-point literal))用于表示十进制实数和编码(十六进制实数)。
* 格式
  * `[{+, -}] integer.[integer] [E[{+, -}]integer]`

### 字符常量

* 字符常量(character literal), 用单引号或者双引号包含的一个字符。汇编器在内存中保存的是该字符二进制ASCII码的数值

### 字符串常量

* 字符串常量(string literal): 是用单引号或者双引号包含的一个字符(含空格符)序列：
  * 'ABC'
  * 'X'
  * "Good night, Gracit"
  * '4096'

### 保留字

* 保留字(reserved words)由特殊意义并且只能在其正确的上下文中实用，默认情况下，保留字没有大小写之分，比如MOV与mov相同。 保留字有不同类型	
  * 指令助记符，如MOV, ADD, MUL
  * 寄存器名称
  * 伪指令： 告诉汇编器如何汇编程序
  * 属性，提供变量和操作数的大小与使用信息，例如BYTE和WORD
  * 运算符，在常量表达式中使用
  * 预定义符号，比如@data, 他在汇编时返回常量的整数值

### 标识符

* 标识符(identifier)是由程序员定义的名称，它用于标识变量，常量，子程序和代码标签，如下规则
  * 可以包含1~247个字符
  * 不区分大小写
  * 第一个字符必须为字母(A...Z, a-z),下划线(_), @, ?, $.其后字符也可以是数字
  * 标识符不能与汇编器保留字相同
  * 一般，避免使用符号@和下划线作为第一个字符，因为他们用于汇编器，也用于高级语言编译器。

### 伪指令

* 伪指令(directive)是嵌入源代码中的命令，由编译器识别和执行。伪指令不在运行时执行，但他们可以定义常量，宏和子程序， 为内存段分配名称。执行许多其他与编译器相关的日常任务。
  * 尽管Intel处理器所有汇编器使用相同指令集，但是通常他们有着不同的伪指令。
* 伪指令
  1. 定义段：程序中的段具有不同的作用
* 常用伪指令
  * 一个段可以用于定义变量，.data
  * 可以用于标识程序区段包含可执行指令: .code
  * 可以使用.STACK伪指令标识程序区段定义了运行时堆栈。

### 指令

* 指令(instruction)是一种语句，他在程序汇编编译时变得可执行，汇编器将指令翻译为机器语言字节，并在运行时由CPU加载执行，一条指令由四个组成部分
  * 标号(可选)
  * 指令助记符(必须)
  * 操作数(通常必须)
  * 注释(可选)
* 格式
  * `[lable:]mnemonic[operands] [;comment]`

#### 标号

1. 标号

   * 标号(label)是一种标识符，是指令和数据的位置标记，标号位于指令的前端，表示指令的地址。同样标号也位于变量的前端，表示变量的地址，标号有两种： 数据标号和代码标号

2. 数据标号和代码标号

   1. 数据标号： 标识变量的位置，提供了一种方便的手段在代码中引用该变量

      * `count DWORD 100`

      * 编译器为每个标号分配一个数字地址，可以在一个标号后面定义多个数据项目

        ```asm
        array DWORD 1024, 2048
        	 DWORD 4096, 8192
        ```

   2. 程序代码区(指令所在区段)的标号必须用冒号(:)结束，代码标号用作跳转与循环指令的目标。

#### 指令助记符号

* 指令助记符(instruction mnemonic): 是标记一条指令的短单词。
* 例如
  * MOV： 传送分配的数值
  * ADD:  两个数值相加
  * SUB： 从一个数值中减去另一个数值
  * MUL： 两个数值相乘
  * JMP： 跳转到一个新位置
  * CALL： 调用子程序

#### 操作数

* 操作数是指令输入输出的数值。汇编语言指令操作数的个数范围是0~3个， 每个操作数可以是寄存器，内存操作数，整数表达式和输入输出端口。
* 一些包含不同个数操作数的汇编语言指令示例
  1. 进位标志位置一
     * `stc`
  2. 自增
     * `inc eax`
  3. mov指令
     * `mov count, ebx`
     * 操作数有固有顺序，当有多个操作数，第一个操作数一般为目的操作数，第二个操作数称为原操作数
  4. IMUL指令
     * `imul eax, ebx, 5`
     * 目的操作数，原操作，原操作数

#### 注释

1. 单行注释: `;`

2. 多行注释

   ```asm
   COMMENT !
   	This is Comment
   ！
   ```

#### NOP (空操作)指令

* 最安全的指令，在程序空间占用一个字节。
* 一般被编译器和汇编器用于将代码对齐到有效的地址边界。
* x86处理器被设计为从双字节的偶数倍地址处加载代码和数据。

## 整数加减法

### AddTwo程序

```asm
; AddTwo.asm	- 两个32位整数相加
; 第三章实例

.386	; 表示是一个32位程序，能访问32位寄存器和地址
.model flat, stdcall ; 选择程序是内存模式(flat),并确定子程序调用规范(stdcall)
; 32位程序，总是使用平面flat存储模式，与处理器的保护模式相关联
; stdcall 在调用程序时告诉编译器，怎么管理运行时堆栈
.stack 4096
; 堆栈
	; 1. 用来保存传递的参数
	; 2. 用来保存调用函数的代码的地址，(调用结束返回)
	; 3. 可以用于保存局部变量
ExitProcess PROTO, dwExitCode:DWORD

.code	; 程序代码区起点
main PROC
	mov eax, 5	; 数字5送入eax寄存器
	add eax, 6	; eax寄存器加6
	
	INVOKE ExitProcess, 0
main ENDP
END main ; 标记程序最后一行，同时标识程序入口
```

## 汇编 - 连接 - 可执行程序

* 运行过程
  1. 编写源文件
  2. 汇编器读取，生成目标文件
  3. 链接器读取并检查目标文件，连接链接库调用
  4. 操作系统加载程序将可执行程序读入内存

* 列表文件
  * 列表文件包含了程序源文件的副本，再加上行号，每条指令的数字地址，每条指令的机器代码字节(十六进制)以及符号表
  * 符号表： 包含程序中所有标识符名字，段和相关信息
  * `invoke`： push , call

## 定义数据

* 汇编器识别一组基本的内部数据类型(intrinsic data type), 按照数据大小，是否有符号，是整数还是实数来描述其类型
  * 但是汇编器只会确定操作数的大小
* 数据定义语句 : 在内存中为变量留出存储空间，并赋予一个可选的名字
  * `name directive init`
* 基本数据类型
  * BYTE
  * SBYTE
  * WORD
  * SWORD
  * DWORD
  * SDWORD
  * FWORD:  48位
  * QWORD: 64位
  * TBYTE: 80位
  * REAL4
  * REAL8
  * REAL10
* 传统数据定义
  * DB
  * DW
  * DD
  * DQ
  * DDT
* 定义BYTE和SBYTE数据
  * `val BYTE 'A'`
  * `val SBYTE 0`
  * `val SBYTE -127`
* 定义字符串
  * `str BYTE "Good afternoon", 0`
* DUP操作符
  * `DUP`操作符使用一个整数表达式作为计数器，位多个数据项分配存储空间。
  * `BYTE 20 DUP(0)`

* 32位可以定义另一个数据的偏移量
  * `pVal DWORD val2`